\section{Event Detector}
\label{sec-detector}

The inputs to PocketParker's availability estimation algorithm are arrival
and departure events generated by an activity detector running unattended in
each users pocket. While a great deal of previous research has explored
activity detection using sensor on mobile devices~\cite{FIXME}, we designed a
simple custom parking event detector tailored to the goals of PocketParker.
In addition to being designed and tuned to the specifics of our detection
problem, our event detector can also utilize the structure of our monitoring
problem to reduce false positives. In this section, we describe our event
detector and the portions of the PocketParker system that run on the
smartphone itself.

\subsection{Parking Events}
\label{subsec-goals}

PocketParker assumes that transitions between walking and driving that occur
in locations known to be parking lots constitute either arrival (driving to
walking) or departure (walking to driving) events. Thus, we must be able to
efficiently detect walking and driving activities, and detect transitions
fast enough to determine the location of the parking lot in which the event
took place. While all these states could be detected using
continuously-sampled GPS data, this would consume too much energy to be an
effective pocketsourcing solution.

Instead, we rely on duty-cycled accelerometer data to classify the user into
one of three states: walking, driving, or idle.

The application needs to determine the state of the user---whether walking,
driving or idle---with a test that is simple, quick and reasonably effective
for our goals. We rely solely on accelerometer data for an initial
determination of state, as continuously cycled GPS sensing would consume too
much power. An accelerometer :15 duty cycle, with :05 sensing and :10 idle
periods, proved optimal. Five seconds was the minimum time necessary to
detect sensing activity accurately. We also wanted to obtain two sensing
periods within a short period of time for confirmation.

The initial test for user state relies on the standard deviation of sampled
accelerometer data within a sensing period.  Our application first feeds
readings through a Kallman smoothing filter to suppress ambient sensor noise
and other low amplitude signals.  A standard deviation of the processed
signal of less than .15 m/s [FIX] implies a user state of idle, a measurement
above .50 m/s [FIX] to that of walking, and values in between to driving. The
application stores a history of user states for future reference. From this
history, we define the user steady state to be whatever state, if any,
constitutes a majority of the individual states observed within the last
nine periods.

We use user state, in turn, to determine parking arrival events. The program
determines that a parking event has transpired when three conditions are
satisfied. The user steady state must be driving and the last individual
state observed must be walking. Further, the frequency of high amplitude
peaks in the last sample must correspond to that of the mean human gait.
This test catches the large majority of parking events, where people park
their cars and immediately begin walking.

However, drivers occasionally sit in their cars for a period before leaving.
To catch this type of parking event, the program employs a second test.
Unfortunately, simply observing a state transition from driving to idle is
not, by itself, reliably determinative.  While the walking and idle states
exhibit consistent well defined patterns, the driving state presents with
more fluctuation.  The steady state of driving often contains individual
idle state periods.  Rather, the program concludes that a driver has parked
only when the user steady state transcends from driving to idle to walking
within a three-minute period.

When the program concludes that a user has parked, it turns on GPS detection
long enough to determine the walking velocity and bearing of the user. It
then calculates backwards to estimate the location where the user started
walking---that is, to the parking spot.

Occasionally, a user upon parking will walk for too brief a period before
entering a building for the program to obtain a location from GPS.  In our
target market of the SUNY Buffalo campus, this is an uncommon occurrence in
practice, as there are few parking spots close enough to buildings to permit
this situation to transpire.  A reliable watermark for this rarity is a
steady driving state coupled with a most recent individual walking state and
a null GPS reading.  In this situation, we employ alternative Android
location providers such as WiFi to determine user locale.

While walking, users may change their bearing.  If this occurs before the
first GPS fix, [ONLY??] the app may not be able to calculate the original
location of the parking spot.  An apparent remedy to this would be to use
compass data to detect changes in bearing.  This would work if the relative 
orientation of the phone viz-a-viz the user were also detectable.  In
practice, when not in use mobile phones are typically oriented randomly by
users, particularly when placed in pockets and backpacks.  Sticking solely
with GPS data has thus proven better.

A final potential issue with detecting a parking event is that of a driving
period too short to for the program to detect that a user is driving in
the first place.  This situation would occur when a user simply moved his
car to a new parking spot in an adjacent row.  This is not a worrisome
problem, as it does not stem from rational user behavior.


...report parking event to server...


We avoided implementing more complex algorithms that would have impacted
battery life...


